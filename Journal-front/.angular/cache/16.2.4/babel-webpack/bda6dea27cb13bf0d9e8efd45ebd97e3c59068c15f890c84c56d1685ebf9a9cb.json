{"ast":null,"code":"export class Configuration {\n  constructor(configurationParameters = {}) {\n    this.apiKeys = configurationParameters.apiKeys;\n    this.username = configurationParameters.username;\n    this.password = configurationParameters.password;\n    this.accessToken = configurationParameters.accessToken;\n    this.basePath = configurationParameters.basePath;\n    this.withCredentials = configurationParameters.withCredentials;\n    this.encoder = configurationParameters.encoder;\n    if (configurationParameters.encodeParam) {\n      this.encodeParam = configurationParameters.encodeParam;\n    } else {\n      this.encodeParam = param => this.defaultEncodeParam(param);\n    }\n    if (configurationParameters.credentials) {\n      this.credentials = configurationParameters.credentials;\n    } else {\n      this.credentials = {};\n    }\n  }\n  /**\n   * Select the correct content-type to use for a request.\n   * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n   * If no content type is found return the first found type if the contentTypes is not empty\n   * @param contentTypes - the array of content types that are available for selection\n   * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n   */\n  selectHeaderContentType(contentTypes) {\n    if (contentTypes.length === 0) {\n      return undefined;\n    }\n    const type = contentTypes.find(x => this.isJsonMime(x));\n    if (type === undefined) {\n      return contentTypes[0];\n    }\n    return type;\n  }\n  /**\n   * Select the correct accept content-type to use for a request.\n   * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n   * If no content type is found return the first found type if the contentTypes is not empty\n   * @param accepts - the array of content types that are available for selection.\n   * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n   */\n  selectHeaderAccept(accepts) {\n    if (accepts.length === 0) {\n      return undefined;\n    }\n    const type = accepts.find(x => this.isJsonMime(x));\n    if (type === undefined) {\n      return accepts[0];\n    }\n    return type;\n  }\n  /**\n   * Check if the given MIME is a JSON MIME.\n   * JSON MIME examples:\n   *   application/json\n   *   application/json; charset=UTF8\n   *   APPLICATION/JSON\n   *   application/vnd.company+json\n   * @param mime - MIME (Multipurpose Internet Mail Extensions)\n   * @return True if the given MIME is JSON, false otherwise.\n   */\n  isJsonMime(mime) {\n    const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n  }\n  lookupCredential(key) {\n    const value = this.credentials[key];\n    return typeof value === 'function' ? value() : value;\n  }\n  defaultEncodeParam(param) {\n    // This implementation exists as fallback for missing configuration\n    // and for backwards compatibility to older typescript-angular generator versions.\n    // It only works for the 'simple' parameter style.\n    // Date-handling only works for the 'date-time' format.\n    // All other styles and Date-formats are probably handled incorrectly.\n    //\n    // But: if that's all you need (i.e.: the most common use-case): no need for customization!\n    const value = param.dataFormat === 'date-time' && param.value instanceof Date ? param.value.toISOString() : param.value;\n    return encodeURIComponent(String(value));\n  }\n}","map":{"version":3,"names":["Configuration","constructor","configurationParameters","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","encodeParam","param","defaultEncodeParam","credentials","selectHeaderContentType","contentTypes","length","undefined","type","find","x","isJsonMime","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","lookupCredential","key","value","dataFormat","Date","toISOString","encodeURIComponent","String"],"sources":["C:\\Users\\waela\\OneDrive\\Documents\\finalYearProject\\Journal-front\\src\\journal-api\\src\\configuration.ts"],"sourcesContent":["import { HttpParameterCodec } from '@angular/common/http';\nimport { Param } from './param';\n\nexport interface ConfigurationParameters {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    /**\n     * Takes care of encoding query- and form-parameters.\n     */\n    encoder?: HttpParameterCodec;\n    /**\n     * Override the default method for encoding path parameters in various\n     * <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-values\">styles</a>.\n     * <p>\n     * See {@link README.md} for more details\n     * </p>\n     */\n    encodeParam?: (param: Param) => string;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials?: {[ key: string ]: string | (() => string | undefined)};\n}\n\nexport class Configuration {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    /**\n     * Takes care of encoding query- and form-parameters.\n     */\n    encoder?: HttpParameterCodec;\n    /**\n     * Encoding of various path parameter\n     * <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-values\">styles</a>.\n     * <p>\n     * See {@link README.md} for more details\n     * </p>\n     */\n    encodeParam: (param: Param) => string;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials: {[ key: string ]: string | (() => string | undefined)};\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n        if (configurationParameters.encodeParam) {\n            this.encodeParam = configurationParameters.encodeParam;\n        }\n        else {\n            this.encodeParam = param => this.defaultEncodeParam(param);\n        }\n        if (configurationParameters.credentials) {\n            this.credentials = configurationParameters.credentials;\n        }\n        else {\n            this.credentials = {};\n        }\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n\n    public lookupCredential(key: string): string | undefined {\n        const value = this.credentials[key];\n        return typeof value === 'function'\n            ? value()\n            : value;\n    }\n\n    private defaultEncodeParam(param: Param): string {\n        // This implementation exists as fallback for missing configuration\n        // and for backwards compatibility to older typescript-angular generator versions.\n        // It only works for the 'simple' parameter style.\n        // Date-handling only works for the 'date-time' format.\n        // All other styles and Date-formats are probably handled incorrectly.\n        //\n        // But: if that's all you need (i.e.: the most common use-case): no need for customization!\n\n        const value = param.dataFormat === 'date-time' && param.value instanceof Date\n            ? (param.value as Date).toISOString()\n            : param.value;\n\n        return encodeURIComponent(String(value));\n    }\n}\n"],"mappings":"AAoCA,OAAM,MAAOA,aAAa;EAgCtBC,YAAYC,uBAAA,GAAmD,EAAE;IAC7D,IAAI,CAACC,OAAO,GAAGD,uBAAuB,CAACC,OAAO;IAC9C,IAAI,CAACC,QAAQ,GAAGF,uBAAuB,CAACE,QAAQ;IAChD,IAAI,CAACC,QAAQ,GAAGH,uBAAuB,CAACG,QAAQ;IAChD,IAAI,CAACC,WAAW,GAAGJ,uBAAuB,CAACI,WAAW;IACtD,IAAI,CAACC,QAAQ,GAAGL,uBAAuB,CAACK,QAAQ;IAChD,IAAI,CAACC,eAAe,GAAGN,uBAAuB,CAACM,eAAe;IAC9D,IAAI,CAACC,OAAO,GAAGP,uBAAuB,CAACO,OAAO;IAC9C,IAAIP,uBAAuB,CAACQ,WAAW,EAAE;MACrC,IAAI,CAACA,WAAW,GAAGR,uBAAuB,CAACQ,WAAW;KACzD,MACI;MACD,IAAI,CAACA,WAAW,GAAGC,KAAK,IAAI,IAAI,CAACC,kBAAkB,CAACD,KAAK,CAAC;;IAE9D,IAAIT,uBAAuB,CAACW,WAAW,EAAE;MACrC,IAAI,CAACA,WAAW,GAAGX,uBAAuB,CAACW,WAAW;KACzD,MACI;MACD,IAAI,CAACA,WAAW,GAAG,EAAE;;EAE7B;EAEA;;;;;;;EAOOC,uBAAuBA,CAAEC,YAAsB;IAClD,IAAIA,YAAY,CAACC,MAAM,KAAK,CAAC,EAAE;MAC3B,OAAOC,SAAS;;IAGpB,MAAMC,IAAI,GAAGH,YAAY,CAACI,IAAI,CAAEC,CAAS,IAAK,IAAI,CAACC,UAAU,CAACD,CAAC,CAAC,CAAC;IACjE,IAAIF,IAAI,KAAKD,SAAS,EAAE;MACpB,OAAOF,YAAY,CAAC,CAAC,CAAC;;IAE1B,OAAOG,IAAI;EACf;EAEA;;;;;;;EAOOI,kBAAkBA,CAACC,OAAiB;IACvC,IAAIA,OAAO,CAACP,MAAM,KAAK,CAAC,EAAE;MACtB,OAAOC,SAAS;;IAGpB,MAAMC,IAAI,GAAGK,OAAO,CAACJ,IAAI,CAAEC,CAAS,IAAK,IAAI,CAACC,UAAU,CAACD,CAAC,CAAC,CAAC;IAC5D,IAAIF,IAAI,KAAKD,SAAS,EAAE;MACpB,OAAOM,OAAO,CAAC,CAAC,CAAC;;IAErB,OAAOL,IAAI;EACf;EAEA;;;;;;;;;;EAUOG,UAAUA,CAACG,IAAY;IAC1B,MAAMC,QAAQ,GAAW,IAAIC,MAAM,CAAC,+DAA+D,EAAE,GAAG,CAAC;IACzG,OAAOF,IAAI,KAAK,IAAI,KAAKC,QAAQ,CAACE,IAAI,CAACH,IAAI,CAAC,IAAIA,IAAI,CAACI,WAAW,EAAE,KAAK,6BAA6B,CAAC;EACzG;EAEOC,gBAAgBA,CAACC,GAAW;IAC/B,MAAMC,KAAK,GAAG,IAAI,CAAClB,WAAW,CAACiB,GAAG,CAAC;IACnC,OAAO,OAAOC,KAAK,KAAK,UAAU,GAC5BA,KAAK,EAAE,GACPA,KAAK;EACf;EAEQnB,kBAAkBA,CAACD,KAAY;IACnC;IACA;IACA;IACA;IACA;IACA;IACA;IAEA,MAAMoB,KAAK,GAAGpB,KAAK,CAACqB,UAAU,KAAK,WAAW,IAAIrB,KAAK,CAACoB,KAAK,YAAYE,IAAI,GACtEtB,KAAK,CAACoB,KAAc,CAACG,WAAW,EAAE,GACnCvB,KAAK,CAACoB,KAAK;IAEjB,OAAOI,kBAAkB,CAACC,MAAM,CAACL,KAAK,CAAC,CAAC;EAC5C"},"metadata":{},"sourceType":"module","externalDependencies":[]}